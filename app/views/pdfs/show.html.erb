<div class="max-w-6xl mx-auto p-8">
  <!-- PDF Info Card -->
  <div class="bg-white rounded-lg shadow-md p-6 mb-6">
    <!-- Top Row: Title and View HTML -->
    <div class="flex justify-between items-center mb-4">
      <div class="flex-1">
        <h2 class="text-2xl font-bold cursor-pointer hover:text-gray-700 transition-colors"
            id="pdf-name-display"
            onclick="editPdfName()"
            title="Click to edit">
          <%= @pdf.name %>
        </h2>
        <input type="text"
               id="pdf-name-input"
               class="hidden text-2xl font-bold bg-gray-100 px-2 py-1 rounded border border-gray-300 focus:outline-none focus:border-blue-500 w-full max-w-2xl"
               value="<%= @pdf.name %>"
               onblur="savePdfName()"
               onkeydown="handlePdfNameKeydown(event)" />
      </div>
      <%= link_to "View HTML", html_game_pdf_path(@game, @pdf),
          class: "bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors" %>
    </div>

    <% if @pdf.description.present? %>
      <div class="mb-4">
        <h3 class="text-lg font-semibold mb-2">Description</h3>
        <p class="text-gray-700"><%= @pdf.description %></p>
      </div>
    <% end %>

    <div class="text-sm text-gray-500 mb-4">
      <p>Created: <%= @pdf.created_at.strftime("%B %d, %Y at %I:%M %p") %></p>
    </div>

    <!-- Bottom Row: Action Buttons -->
    <div class="flex flex-wrap gap-2 pt-4 border-t border-gray-200">
      <%= button_to "Extract Text", run_job_game_pdf_path(@game, @pdf, method: :extract_text),
          method: :post,
          class: "bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors",
          data: { turbo_confirm: "This will re-extract and refine the text content. Continue?" } %>
      <%= button_to "Refine Text", run_job_game_pdf_path(@game, @pdf, method: :refine_text),
          method: :post,
          class: "bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors",
          data: { turbo_confirm: "This will refine the text content. Continue?" } %>
      <%= button_to "Extract HTML", run_job_game_pdf_path(@game, @pdf, method: :extract_html),
          method: :post,
          class: "bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors",
          data: { turbo_confirm: "This will extract the HTML content. Continue?" } %>
      <%= button_to "Extract Images", run_job_game_pdf_path(@game, @pdf, method: :extract_images),
          method: :post,
          class: "bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors",
          data: { turbo_confirm: "This will extract the images. Continue?" } %>
      <%= button_to "Extract Metadata", run_job_game_pdf_path(@game, @pdf, method: :extract_metadata),
          method: :post,
          class: "bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors",
          data: { turbo_confirm: "This will extract the metadata. Continue?" } %>
      <%= button_to "Classify Images", run_job_game_pdf_path(@game, @pdf, method: :classify_images),
          method: :post,
          class: "bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors",
          data: { turbo_confirm: "This will classify the images. Continue?" } %>
    </div>
  </div>

  <!-- Text Content -->
  <% if @pdf.text_content.present? %>
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
      <h3 class="text-lg font-semibold mb-4">Text Content <span class="text-sm text-gray-500 font-normal">(click to edit)</span></h3>
      <div id="text-content-display"
           class="prose prose-sm max-w-none text-gray-700 whitespace-pre-wrap font-mono text-xs bg-gray-50 p-4 rounded border border-gray-200 max-h-96 overflow-y-auto cursor-pointer hover:bg-gray-100 transition-colors"
           onclick="editTextContent()"
           title="Click to edit"><%= @pdf.text_content %></div>
      <textarea id="text-content-input"
                class="hidden w-full h-96 font-mono text-xs bg-white p-4 rounded border border-gray-300 focus:outline-none focus:border-blue-500 resize-y"
                onblur="saveTextContent()"><%= @pdf.text_content %></textarea>
      <div id="text-content-actions" class="hidden mt-2 flex gap-2">
        <button onclick="saveTextContent()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors">
          Save
        </button>
        <button onclick="cancelTextEdit()" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors">
          Cancel
        </button>
      </div>
    </div>
  <% end %>

  <!-- Images Grid -->
  <div class="bg-white rounded-lg shadow-md p-6">
    <!-- Upload Images Section -->
    <div class="mb-6 border-b border-gray-200 pb-6">
      <h3 class="text-lg font-semibold mb-4">Upload Images</h3>
      <%= form_with url: upload_images_game_pdf_path(@game, @pdf), method: :post, multipart: true, id: "upload-images-form" do |f| %>
        <div class="flex items-center gap-4">
          <div class="flex-1">
            <input type="file" name="images[]" id="image-upload-input" multiple accept="image/*" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
          </div>
          <button type="submit" id="upload-btn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
            Upload <span id="upload-count"></span>
          </button>
        </div>
        <p class="text-xs text-gray-500 mt-2">Select one or more images to upload. Supported formats: JPG, PNG, GIF, WebP</p>
      <% end %>
    </div>

    <% if @images.any? %>
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Images (<%= @images.count %>)</h3>
        <div class="flex gap-2">
          <button id="select-all-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors">
            Select All
          </button>
          <%= form_with url: delete_images_game_pdf_path(@game, @pdf), method: :post, id: "delete-images-form", class: "inline" do |f| %>
            <div id="selected-images-input"></div>
            <button type="submit" id="delete-selected-btn" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-medium text-sm transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
              Delete Selected (<span id="selected-count">0</span>)
            </button>
          <% end %>
        </div>
      </div>
      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4" id="images-grid">
        <% @images.each do |image| %>
          <div class="border border-gray-200 rounded-lg overflow-hidden hover:shadow-lg transition-shadow image-card" data-image-id="<%= image.id %>" tabindex="0">
            <div class="relative">
              <%= link_to game_pdf_image_path(@game, @pdf, image.id), class: "block" do %>
                <%= image_tag image, class: "w-full h-48 object-contain bg-gray-100" %>
              <% end %>
              <div class="absolute top-2 right-2">
                <input type="checkbox" class="image-checkbox w-5 h-5 rounded border-gray-300" data-image-id="<%= image.id %>" onclick="event.stopPropagation()">
              </div>
            </div>
            <div class="p-3 bg-gray-50">
              <% if image.blob.metadata['classification'].present? %>
                <div class="mb-2 flex items-center gap-2">
                  <span class="inline-block px-2 py-1 text-xs font-semibold rounded bg-blue-100 text-blue-800">
                    <%= image.blob.metadata['classification'] %>
                  </span>
                  <% if image.blob.metadata['recommendation'] == 'remove' %>
                    <span class="inline-block px-2 py-1 text-xs font-semibold rounded bg-red-100 text-red-800">
                      Remove
                    </span>
                  <% end %>
                </div>
              <% end %>
              <% if image.blob.metadata['description'].present? %>
                <%= link_to game_pdf_image_path(@game, @pdf, image.id), class: "block" do %>
                  <p class="text-xs text-gray-600 line-clamp-3"><%= image.blob.metadata['description'] %></p>
                <% end %>
              <% else %>
                <%= link_to game_pdf_image_path(@game, @pdf, image.id), class: "block" do %>
                  <p class="text-xs text-gray-400 italic">No description available</p>
                <% end %>
              <% end %>
            </div>
          </div>
        <% end %>
      </div>
    <% else %>
      <p class="text-gray-500 italic">No images have been extracted or uploaded yet.</p>
    <% end %>
  </div>
</div>

<style>
  .image-card:focus {
    outline: 3px solid #3b82f6;
    outline-offset: 2px;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // File upload handling
    const uploadInput = document.getElementById('image-upload-input');
    const uploadBtn = document.getElementById('upload-btn');
    const uploadCountSpan = document.getElementById('upload-count');

    if (uploadInput && uploadBtn) {
      uploadInput.addEventListener('change', function() {
        const fileCount = this.files.length;
        uploadBtn.disabled = fileCount === 0;

        if (fileCount > 0) {
          uploadCountSpan.textContent = `(${fileCount})`;
        } else {
          uploadCountSpan.textContent = '';
        }
      });
    }

    // Image deletion handling
    const checkboxes = document.querySelectorAll('.image-checkbox');
    const imageCards = document.querySelectorAll('.image-card');
    const selectAllBtn = document.getElementById('select-all-btn');
    const deleteBtn = document.getElementById('delete-selected-btn');
    const selectedCountSpan = document.getElementById('selected-count');
    const selectedImagesInput = document.getElementById('selected-images-input');
    const deleteForm = document.getElementById('delete-images-form');
    const imagesGrid = document.getElementById('images-grid');

    if (checkboxes.length > 0 && deleteBtn) {
      function updateDeleteButton() {
        const selectedCheckboxes = Array.from(checkboxes).filter(cb => cb.checked);
        const count = selectedCheckboxes.length;

        selectedCountSpan.textContent = count;
        deleteBtn.disabled = count === 0;

        // Update hidden input with selected image IDs
        selectedImagesInput.innerHTML = '';
        selectedCheckboxes.forEach(cb => {
          const input = document.createElement('input');
          input.type = 'hidden';
          input.name = 'image_ids[]';
          input.value = cb.dataset.imageId;
          selectedImagesInput.appendChild(input);
        });

        // Update select all button text
        if (count === checkboxes.length) {
          selectAllBtn.textContent = 'Deselect All';
        } else {
          selectAllBtn.textContent = 'Select All';
        }
      }

      // Handle checkbox changes
      checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updateDeleteButton);
      });

      // Handle select all button
      selectAllBtn.addEventListener('click', function() {
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        checkboxes.forEach(cb => cb.checked = !allChecked);
        updateDeleteButton();
      });

      // Handle form submission with confirmation
      deleteForm.addEventListener('submit', function(e) {
        const count = Array.from(checkboxes).filter(cb => cb.checked).length;
        if (!confirm(`Are you sure you want to delete ${count} image(s)? This action cannot be undone.`)) {
          e.preventDefault();
        }
      });

      // Keyboard navigation for image cards
      function getGridColumns() {
        // Get computed grid-template-columns to determine current number of columns
        const gridStyle = window.getComputedStyle(imagesGrid);
        const columns = gridStyle.gridTemplateColumns.split(' ').length;
        return columns;
      }

      function getCurrentCardIndex(card) {
        return Array.from(imageCards).indexOf(card);
      }

      function focusCard(card) {
        if (card) {
          card.focus();
        }
      }

      // Handle clicking on card - focus it
      imageCards.forEach(card => {
        card.addEventListener('click', function(e) {
          // Only focus if not clicking on checkbox or link
          if (!e.target.matches('.image-checkbox') && !e.target.closest('a')) {
            this.focus();
          }
        });

        // Handle checkbox click - focus the card
        const checkbox = card.querySelector('.image-checkbox');
        if (checkbox) {
          checkbox.addEventListener('change', function() {
            card.focus();
          });
        }
      });

      // Handle keyboard navigation
      imageCards.forEach(card => {
        card.addEventListener('keydown', function(e) {
          const currentIndex = getCurrentCardIndex(this);
          const columns = getGridColumns();
          let targetIndex = null;

          switch(e.key) {
            case 'ArrowLeft':
              e.preventDefault();
              targetIndex = currentIndex - 1;
              if (targetIndex >= 0) {
                focusCard(imageCards[targetIndex]);
              }
              break;

            case 'ArrowRight':
              e.preventDefault();
              targetIndex = currentIndex + 1;
              if (targetIndex < imageCards.length) {
                focusCard(imageCards[targetIndex]);
              }
              break;

            case 'ArrowUp':
              e.preventDefault();
              targetIndex = currentIndex - columns;
              if (targetIndex >= 0) {
                focusCard(imageCards[targetIndex]);
              }
              break;

            case 'ArrowDown':
              e.preventDefault();
              targetIndex = currentIndex + columns;
              if (targetIndex < imageCards.length) {
                focusCard(imageCards[targetIndex]);
              }
              break;

            case ' ':
              e.preventDefault();
              const checkbox = this.querySelector('.image-checkbox');
              if (checkbox) {
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
              }
              break;
          }
        });
      });

      updateDeleteButton();
    }

    // PDF name editing
    let originalPdfName = '<%= j @pdf.name %>';

    window.editPdfName = function() {
      const display = document.getElementById('pdf-name-display');
      const input = document.getElementById('pdf-name-input');

      if (!display || !input) return;

      display.classList.add('hidden');
      input.classList.remove('hidden');
      input.focus();
      input.select();
    };

    window.cancelPdfEdit = function() {
      const display = document.getElementById('pdf-name-display');
      const input = document.getElementById('pdf-name-input');

      if (!display || !input) return;

      input.value = originalPdfName;
      input.classList.add('hidden');
      display.classList.remove('hidden');
    };

    window.savePdfName = function() {
      const display = document.getElementById('pdf-name-display');
      const input = document.getElementById('pdf-name-input');

      if (!display || !input) return;

      const newName = input.value.trim();

      // If name hasn't changed or is empty, just cancel
      if (newName === originalPdfName || newName === '') {
        cancelPdfEdit();
        return;
      }

      // Save via AJAX
      fetch('<%= game_pdf_path(@game, @pdf) %>', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        },
        body: JSON.stringify({
          pdf: { name: newName }
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          originalPdfName = data.name;
          display.textContent = data.name;
          input.value = data.name;
          input.classList.add('hidden');
          display.classList.remove('hidden');
        } else {
          alert('Failed to update PDF name: ' + (data.errors || ['Unknown error']).join(', '));
          cancelPdfEdit();
        }
      })
      .catch(error => {
        console.error('Error:', error);
        alert('Failed to update PDF name');
        cancelPdfEdit();
      });
    };

    window.handlePdfNameKeydown = function(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        savePdfName();
      } else if (event.key === 'Escape') {
        event.preventDefault();
        cancelPdfEdit();
      }
    };

    // Text content editing
    let originalTextContent = '<%= j @pdf.text_content %>';
    let isEditingText = false;

    window.editTextContent = function() {
      const display = document.getElementById('text-content-display');
      const input = document.getElementById('text-content-input');
      const actions = document.getElementById('text-content-actions');

      if (!display || !input || !actions) return;

      isEditingText = true;
      display.classList.add('hidden');
      input.classList.remove('hidden');
      actions.classList.remove('hidden');
      input.focus();
    };

    window.cancelTextEdit = function() {
      const display = document.getElementById('text-content-display');
      const input = document.getElementById('text-content-input');
      const actions = document.getElementById('text-content-actions');

      if (!display || !input || !actions) return;

      isEditingText = false;
      input.value = originalTextContent;
      input.classList.add('hidden');
      actions.classList.add('hidden');
      display.classList.remove('hidden');
    };

    window.saveTextContent = function() {
      // If not editing, don't save (this prevents onblur from triggering save when clicking buttons)
      if (!isEditingText) return;

      const display = document.getElementById('text-content-display');
      const input = document.getElementById('text-content-input');
      const actions = document.getElementById('text-content-actions');

      if (!display || !input || !actions) return;

      const newContent = input.value;

      // If content hasn't changed, just cancel
      if (newContent === originalTextContent) {
        cancelTextEdit();
        return;
      }

      // Disable buttons during save
      const saveBtn = actions.querySelector('button:first-child');
      const cancelBtn = actions.querySelector('button:last-child');
      if (saveBtn) saveBtn.disabled = true;
      if (cancelBtn) cancelBtn.disabled = true;

      // Save via AJAX
      fetch('<%= game_pdf_path(@game, @pdf) %>', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        },
        body: JSON.stringify({
          pdf: { text_content: newContent }
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          originalTextContent = newContent;
          display.textContent = newContent;
          isEditingText = false;
          input.classList.add('hidden');
          actions.classList.add('hidden');
          display.classList.remove('hidden');
        } else {
          alert('Failed to update text content: ' + (data.errors || ['Unknown error']).join(', '));
        }
      })
      .catch(error => {
        console.error('Error:', error);
        alert('Failed to update text content');
      })
      .finally(() => {
        if (saveBtn) saveBtn.disabled = false;
        if (cancelBtn) cancelBtn.disabled = false;
      });
    };
  });
</script>
